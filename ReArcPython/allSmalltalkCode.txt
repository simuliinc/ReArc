
Globals

"SettingParameters"

InputSpaceSize := 400.     "Reference value 200"
NumberOfColumns := 10.   "Reference value 10"

PyramidalsPerColumnLayerOne := 10.   "Reference value 10"
PyramidalsPerColumnLayerTwo := 10.   "Reference value 10"
PyramidalsPerColumnLayerThree := 1.   "Reference value 1"

NumberOfBranchesPerLayerOnePyramidal := 20.   "Reference value 20"
NumberOfBranchesPerLayerTwoPyramidal := 10.   "Reference value 10"
NumberOfBranchesPerLayerThreePyramidal := 10.   "Reference value 10"

NumberOfConditionDefiningInputsPerCorticalLayerOneBranch := 15.   "Reference value 25"
NumberOfConditionDefiningInputsPerCorticalLayerTwoBranch := 15.   "Reference value 15"
NumberOfConditionDefiningInputsPerCorticalLayerThreeBranch := 15.   "Reference value 15"

"In the initial configuration of the cortex, in each column a bias is placed on the random selection of inputs to layer one pyramidals to make the selection of one of the favoured inputs for the column several times more likely than other inputs" 
BiasOnFavouredInputs := 3.   "Reference value 0"

"Initial weights of all synapses on to pyramidal neurons in layers one and two"
CorticalConditionDefiningInputWeight := 1.7.   "Reference value 1.0"

"Initial weights of all synapses on to pyramidal neurons in layer three"
InitialLayerThreeSynapticWeight := 1.0.   "Reference value 1.0"

"Maximum weight of any synapse between pyramidal neurons"
MaximumBranchSynapticWeight := 3.2.   "Reference value 1.7"

HippocampalWeightReductionFactor := 0.9999.
NumberOfConditionRecordingOutputsFromBlackBoxHippocampus := 0.
CorticalConditionRecordingManagementInputWeight := (1/2).


"Total postsynaptic potentials required to inject potential deeper into dendrite"
DendriticBranchThresholdLayerOne := 450.   "Reference value 450"
DendriticBranchThresholdLayerTwo := 450.   "Reference value 450"
DendriticBranchThresholdLayerThree := 200.   "Reference value 400"

"Total postsynaptic potentials required to inject potential from dendrite into soma, causing neuron to fire in layers one and two"
CorticalBasalDendriteThreshold := 985. "Reference value 985"

"Total postsynaptic potentials required to inject potential from dendrite into soma, causing neuron to fire in layer three"
CorticalLayerThreeBasalDendriteThreshold := 700. "Reference value 990"

"Synaptic weights are increased if the synapse gets an input, shortly afterwards the branch injects potential into the dendrite, and shortly after than the neuron fires. However, unless this sequence occurs at least the following number of times within a 200 millisecond period, increases are reversed"
BranchContributionsWithin200msecForPermanentWeightChange := 3.   "Reference value 3"

"If a branch fires a number of times but each time some synapse does not contribute, the weight of that synapse is decreased"BranchFiringsToDecreaseInSynapticWeights := 4.   "Reference value 4"

"Each time a neuron fires, BDNF is released into the local environment. Concentration declines regularly with time, but if the neuron fires often enough that the BDNF concentration reaches a threshold, all regular synapses on the neuron are reduced by the same proportion"
FrequentFiringReductionInSynapticWeightsProportion := 0.9.    "Reference value 0.9"
BDNFincrementPerFiring := 0.5.     "Reference value 0.5"
BDNFconcentrationThresholdForReductionInSynapticWeights :=  17.5.   "Reference value 17.5"
BDNFdecrementFollowingWeightReduction :=  1.   "Reference value 1"
BDNFconcentrationReductionPerTimeslot := 0.9999.    "Reference value 0,9999"

"If feedback is being provided to a category identification, the recommendation weights of active columns that recommended the incorrect identification are reduced by the following factor"
WeightReductionFactor := 1.05.   "Reference value 1.1" 

*Image information*
Image name:   ReferenceImageModJ400characteristicsA1 

Changes from reference parameters:
		NumberOfConditionDefiningInputsPerCorticalLayerOneBranch := 20  20
		NumberOfBranchesPerLayerOnePyramidal := 50  50
		NumberOfColumns := 15.   15

PresentationResults size     783       

													selections
											        1st    2nd    3rd    Total
Learn 601-900; test 901-1200                           
ChangedWeightLearningAlgorithm                      231     42     15      288   /300
     
 "Connectivity is determined at random, and there is a random element in the determination of branch and neuron firing. If two identical images are run, they will have identical results because the Random seed has the same value. To ensure the seed starts from a different point, if exactly the same image is used for different runs, each time execute the following code with different values for n and m."
n := 873 atRandom.
m := 2015 atRandom.
x := OrderedCollection new.
1 to: n do: [:j|
	x addLast: (m atRandom).
	].
^x

----- 

Type A BrainRun [MAIN FILE]

"Type A Brainrun"

	| time nullCategory inputSourceCategoryOne inputSourceCategoryTwo inputSourceCategoryThree inputSourceCategoryFour inputSourceCategoryFive inputSourceCategorySix inputSourceCategorySeven inputSourceCategoryEight inputSourceCategoryNine inputSourceCategoryTen favouredInputs startingSelection simultaneityCount remainingLargest inputSourceCategoryEighteen inputSourceCategoryEleven inputSourceCategoryFifteen inputSourceCategoryFourteen inputSourceCategoryNineteen inputSourceCategorySeventeen inputSourceCategorySixteen inputSourceCategoryThirteen inputSourceCategoryThirty inputSourceCategoryTwelve inputSourceCategoryTwenty inputSourceCategoryTwentyEight inputSourceCategoryTwentyFive inputSourceCategoryTwentyFour inputSourceCategoryTwentyNine inputSourceCategoryTwentyOne inputSourceCategoryTwentySeven inputSourceCategoryTwentySix inputSourceCategoryTwentyThree inputSourceCategoryTwentyTwo |
time := OrderedCollection new.
time addLast: (DateAndTime current ).


"The InputState instances are used to generate sensory input spikes for the different categories. The setting of phase means that the black box thalamus puts the appropriate phase of frequency modulation on different presentations"
inputSourceCategoryOne := InputState new.
inputSourceCategoryOne initialize.
inputSourceCategoryOne setCategory: CategoryOneSpikeProbabilities.
inputSourceCategoryOne setPhaseAtInitialTimeslot: 23.
inputSourceCategoryTwo := InputState new.
inputSourceCategoryTwo initialize.
inputSourceCategoryTwo setCategory: CategoryTwoSpikeProbabilities.
inputSourceCategoryTwo setPhaseAtInitialTimeslot: 23.
inputSourceCategoryThree := InputState new.
inputSourceCategoryThree initialize.
inputSourceCategoryThree setCategory: CategoryThreeSpikeProbabilities.
inputSourceCategoryThree setPhaseAtInitialTimeslot: 23.
inputSourceCategoryFour := InputState new.
inputSourceCategoryFour initialize.
inputSourceCategoryFour setCategory: CategoryFourSpikeProbabilities.
inputSourceCategoryFour setPhaseAtInitialTimeslot: 23.
inputSourceCategoryFive := InputState new.
inputSourceCategoryFive initialize.
inputSourceCategoryFive setCategory: CategoryFiveSpikeProbabilities.
inputSourceCategoryFive setPhaseAtInitialTimeslot: 23.
inputSourceCategorySix := InputState new.
inputSourceCategorySix initialize.
inputSourceCategorySix setCategory: CategorySixSpikeProbabilities.
inputSourceCategorySix setPhaseAtInitialTimeslot: 23.
inputSourceCategorySeven := InputState new.
inputSourceCategorySeven initialize.
inputSourceCategorySeven setCategory: CategorySevenSpikeProbabilities.
inputSourceCategorySeven setPhaseAtInitialTimeslot: 23.
inputSourceCategoryEight := InputState new.
inputSourceCategoryEight initialize.
inputSourceCategoryEight setCategory: CategoryEightSpikeProbabilities.
inputSourceCategoryEight setPhaseAtInitialTimeslot: 23.
inputSourceCategoryNine := InputState new.
inputSourceCategoryNine initialize.
inputSourceCategoryNine setCategory: CategoryNineSpikeProbabilities.
inputSourceCategoryNine setPhaseAtInitialTimeslot: 23.
inputSourceCategoryTen := InputState new.
inputSourceCategoryTen initialize.
inputSourceCategoryTen setCategory: CategoryTenSpikeProbabilities.
inputSourceCategoryTen setPhaseAtInitialTimeslot: 23.
inputSourceCategoryEleven := InputState new.
inputSourceCategoryEleven initialize.
inputSourceCategoryEleven setCategory: CategoryElevenSpikeProbabilities.
inputSourceCategoryEleven setPhaseAtInitialTimeslot: 23.
inputSourceCategoryTwelve := InputState new.
inputSourceCategoryTwelve initialize.
inputSourceCategoryTwelve setCategory: CategoryTwelveSpikeProbabilities.
inputSourceCategoryTwelve setPhaseAtInitialTimeslot: 23.
inputSourceCategoryThirteen := InputState new.
inputSourceCategoryThirteen initialize.
inputSourceCategoryThirteen setCategory: CategoryThirteenSpikeProbabilities.
inputSourceCategoryThirteen setPhaseAtInitialTimeslot: 23.
inputSourceCategoryFourteen := InputState new.
inputSourceCategoryFourteen initialize.
inputSourceCategoryFourteen setCategory: CategoryFourteenSpikeProbabilities.
inputSourceCategoryFourteen setPhaseAtInitialTimeslot: 23.
inputSourceCategoryFifteen := InputState new.
inputSourceCategoryFifteen initialize.
inputSourceCategoryFifteen setCategory: CategoryFifteenSpikeProbabilities.
inputSourceCategoryFifteen setPhaseAtInitialTimeslot: 23.
inputSourceCategorySixteen := InputState new.
inputSourceCategorySixteen initialize.
inputSourceCategorySixteen setCategory: CategorySixteenSpikeProbabilities.
inputSourceCategorySixteen setPhaseAtInitialTimeslot: 23.
inputSourceCategorySeventeen := InputState new.
inputSourceCategorySeventeen initialize.
inputSourceCategorySeventeen setCategory: CategorySeventeenSpikeProbabilities.
inputSourceCategorySeventeen setPhaseAtInitialTimeslot: 23.
inputSourceCategoryEighteen := InputState new.
inputSourceCategoryEighteen initialize.
inputSourceCategoryEighteen setCategory: CategoryEighteenSpikeProbabilities.
inputSourceCategoryEighteen setPhaseAtInitialTimeslot: 23.
inputSourceCategoryNineteen := InputState new.
inputSourceCategoryNineteen initialize.
inputSourceCategoryNineteen setCategory: CategoryNineteenSpikeProbabilities.
inputSourceCategoryNineteen setPhaseAtInitialTimeslot: 23.
inputSourceCategoryTwenty := InputState new.
inputSourceCategoryTwenty initialize.
inputSourceCategoryTwenty setCategory: CategoryTwentySpikeProbabilities.
inputSourceCategoryTwenty setPhaseAtInitialTimeslot: 23.
inputSourceCategoryTwentyOne := InputState new.
inputSourceCategoryTwentyOne initialize.
inputSourceCategoryTwentyOne setCategory: CategoryTwentyOneSpikeProbabilities.
inputSourceCategoryTwentyOne setPhaseAtInitialTimeslot: 23.
inputSourceCategoryTwentyTwo := InputState new.
inputSourceCategoryTwentyTwo initialize.
inputSourceCategoryTwentyTwo setCategory: CategoryTwentyTwoSpikeProbabilities.
inputSourceCategoryTwentyTwo setPhaseAtInitialTimeslot: 23.
inputSourceCategoryTwentyThree := InputState new.
inputSourceCategoryTwentyThree initialize.
inputSourceCategoryTwentyThree setCategory: CategoryTwentyThreeSpikeProbabilities.
inputSourceCategoryTwentyThree setPhaseAtInitialTimeslot: 23.
inputSourceCategoryTwentyFour := InputState new.
inputSourceCategoryTwentyFour initialize.
inputSourceCategoryTwentyFour setCategory: CategoryTwentyFourSpikeProbabilities.
inputSourceCategoryTwentyFour setPhaseAtInitialTimeslot: 23.
inputSourceCategoryTwentyFive := InputState new.
inputSourceCategoryTwentyFive initialize.
inputSourceCategoryTwentyFive setCategory: CategoryTwentyFiveSpikeProbabilities.
inputSourceCategoryTwentyFive setPhaseAtInitialTimeslot: 23.
inputSourceCategoryTwentySix := InputState new.
inputSourceCategoryTwentySix initialize.
inputSourceCategoryTwentySix setCategory: CategoryTwentySixSpikeProbabilities.
inputSourceCategoryTwentySix setPhaseAtInitialTimeslot: 23.
inputSourceCategoryTwentySeven := InputState new.
inputSourceCategoryTwentySeven initialize.
inputSourceCategoryTwentySeven setCategory: CategoryTwentySevenSpikeProbabilities.
inputSourceCategoryTwentySeven setPhaseAtInitialTimeslot: 23.
inputSourceCategoryTwentyEight := InputState new.
inputSourceCategoryTwentyEight initialize.
inputSourceCategoryTwentyEight setCategory: CategoryTwentyEightSpikeProbabilities.
inputSourceCategoryTwentyEight setPhaseAtInitialTimeslot: 23.
inputSourceCategoryTwentyNine := InputState new.
inputSourceCategoryTwentyNine initialize.
inputSourceCategoryTwentyNine setCategory: CategoryTwentyNineSpikeProbabilities.
inputSourceCategoryTwentyNine setPhaseAtInitialTimeslot: 23.
inputSourceCategoryThirty := InputState new.
inputSourceCategoryThirty initialize.
inputSourceCategoryThirty setCategory: CategoryThirtySpikeProbabilities.
inputSourceCategoryThirty setPhaseAtInitialTimeslot: 23.


"The null InputState allows the cortex to be provided with no input spikes for a 25 millisecond period between category instance presentations"
nullCategory := InputState new.
nullCategory initialize.
nullCategory setCategory: NullCategorySpikeProbabilities.
nullCategory setPhaseAtInitialTimeslot: 23.

"Global variables capture a range of information about brain activity at different points"
Y := OrderedCollection new.
Y2 := nil. "OrderedCollection new."

"Y3 records columnsToGetInputFromHippocampus in method Hippocampus updateHippocampalRecordsForMultipleModulationCycles: layerThreeActivity withInternalActivity: layerTwoActivity. Currently suspended"
Y3 := OrderedCollection new.

"YY records hippocampal showStrongActivityCount in method Brain presentTripleCategoryInstance: firstCategoryInputSource withSecondCategory: secondCategoryInputSource withThirdCategory: thirdCategoryInputSource . Currently suspended"
YY := OrderedCollection new.

"Z records the number of spikes in each input state in method InputState getSpikesInNextTimeslot: secondCategoryInputSource withThirdCategory: thirdCategoryInputSource. Currently suspended"
Z := OrderedCollection new.
ZZ := OrderedCollection new.

"Collection of the following five variables (spikes in each timeslot) in method presentTripleCategoryInstance: firstCategoryInputSource withSecondCategory: secondCategoryInputSource withThirdCategory: thirdCategoryInputSource have been INACTIVATED"
InputSpikesPerTimeslot := OrderedCollection new. 
LayerOneSpikesPerTimeslot := OrderedCollection new.
LayerTwoSpikesPerTimeslot := OrderedCollection new.
LayerThreeSpikesPerTimeslot := OrderedCollection new.
RecordingManagementInputsPerTimeslot := OrderedCollection new.

"PresentationResults global variables capture the layer three column outputs in response to each category instance presentation. This information is used by the black box basal ganglia to determine behaviour"
PresentationResults := OrderedCollection new.
PresentationResults2 := OrderedCollection new.

"THE FOLLOWING CODE (to END do: ii) CREATES favouredInputs, WHICH IS AN ORDEREDCOLLECTION OF NumberOfColumns ORDEREDCOLLECTIONS. EACH OF THESE ORDEREDCOLLECTIONS CONTAINS A SET OF INPUTS THAT WILL BE FAVOURED IN CREATING INPUTS TO THE COLUMN. EACH SET IS CREATED BY DEFINING A GROUP OF 50 INPUTS, THEN FINDING THE 25 IN THE 50 THAT ARE MOST OFTEN ACTIVE AT SIMILAR TIMES. MOST OFTEN IS DETERMINED BY MEASURING THE NUMBER OF TIMES EACH INPUT IS ACTIVE AT THE SAME TIME AS AT LEAST 5 OTHER INPUTS IN THE 50, IN PERIODS OF 15 TIMECYCLES (5 MILLISECONDS) WITHIN 10 200 MILLISECOND PRESENTATIONS OF EACH OF FIVE CATEGORIES."
favouredInputs := OrderedCollection new.
1 to: NumberOfColumns do: [:ii|
	startingSelection := Set new.
	1 to: 50 do: [:randomInputs| startingSelection add: (InputSpaceSize atRandom)].
	startingSelection := (startingSelection asOrderedCollection).
	simultaneityCount := OrderedCollection new.
	1 to: (startingSelection size) do: [:jj| simultaneityCount addLast: 0].
	1 to: 10 do: [:presentationCycles|
		simultaneityCount := inputSourceCategoryOne addInputSimultaneityMeasureForOnePeriod: simultaneityCount forInputCombination: startingSelection.
		simultaneityCount := inputSourceCategoryTwo addInputSimultaneityMeasureForOnePeriod: simultaneityCount forInputCombination: startingSelection.
		simultaneityCount := inputSourceCategoryThree addInputSimultaneityMeasureForOnePeriod: simultaneityCount forInputCombination: startingSelection.
		simultaneityCount := inputSourceCategoryFour addInputSimultaneityMeasureForOnePeriod: simultaneityCount forInputCombination: startingSelection.
		simultaneityCount := inputSourceCategoryFive addInputSimultaneityMeasureForOnePeriod: simultaneityCount forInputCombination: startingSelection.
		simultaneityCount := inputSourceCategorySix addInputSimultaneityMeasureForOnePeriod: simultaneityCount forInputCombination: startingSelection.
		simultaneityCount := inputSourceCategorySeven addInputSimultaneityMeasureForOnePeriod: simultaneityCount forInputCombination: startingSelection.
		simultaneityCount := inputSourceCategoryEight addInputSimultaneityMeasureForOnePeriod: simultaneityCount forInputCombination: startingSelection.
		simultaneityCount := inputSourceCategoryNine addInputSimultaneityMeasureForOnePeriod: simultaneityCount forInputCombination: startingSelection.
		simultaneityCount := inputSourceCategoryTen addInputSimultaneityMeasureForOnePeriod: simultaneityCount forInputCombination: startingSelection.
		simultaneityCount := inputSourceCategoryEleven addInputSimultaneityMeasureForOnePeriod: simultaneityCount forInputCombination: startingSelection.
		simultaneityCount := inputSourceCategoryTwelve addInputSimultaneityMeasureForOnePeriod: simultaneityCount forInputCombination: startingSelection.
		simultaneityCount := inputSourceCategoryThirteen addInputSimultaneityMeasureForOnePeriod: simultaneityCount forInputCombination: startingSelection.
		simultaneityCount := inputSourceCategoryFourteen addInputSimultaneityMeasureForOnePeriod: simultaneityCount forInputCombination: startingSelection.
		simultaneityCount := inputSourceCategoryFifteen addInputSimultaneityMeasureForOnePeriod: simultaneityCount forInputCombination: startingSelection.
		simultaneityCount := inputSourceCategorySixteen addInputSimultaneityMeasureForOnePeriod: simultaneityCount forInputCombination: startingSelection.
		simultaneityCount := inputSourceCategorySeventeen addInputSimultaneityMeasureForOnePeriod: simultaneityCount forInputCombination: startingSelection.
		simultaneityCount := inputSourceCategoryEighteen addInputSimultaneityMeasureForOnePeriod: simultaneityCount forInputCombination: startingSelection.
		simultaneityCount := inputSourceCategoryNineteen addInputSimultaneityMeasureForOnePeriod: simultaneityCount forInputCombination: startingSelection.
		simultaneityCount := inputSourceCategoryTwenty addInputSimultaneityMeasureForOnePeriod: simultaneityCount forInputCombination: startingSelection.
		simultaneityCount := inputSourceCategoryTwentyOne addInputSimultaneityMeasureForOnePeriod: simultaneityCount forInputCombination: startingSelection.
		simultaneityCount := inputSourceCategoryTwentyTwo addInputSimultaneityMeasureForOnePeriod: simultaneityCount forInputCombination: startingSelection.
		simultaneityCount := inputSourceCategoryTwentyThree addInputSimultaneityMeasureForOnePeriod: simultaneityCount forInputCombination: startingSelection.
		simultaneityCount := inputSourceCategoryTwentyFour addInputSimultaneityMeasureForOnePeriod: simultaneityCount forInputCombination: startingSelection.
		simultaneityCount := inputSourceCategoryTwentyFive addInputSimultaneityMeasureForOnePeriod: simultaneityCount forInputCombination: startingSelection.
		simultaneityCount := inputSourceCategoryTwentySix addInputSimultaneityMeasureForOnePeriod: simultaneityCount forInputCombination: startingSelection.
		simultaneityCount := inputSourceCategoryTwentySeven addInputSimultaneityMeasureForOnePeriod: simultaneityCount forInputCombination: startingSelection.
		simultaneityCount := inputSourceCategoryTwentyEight addInputSimultaneityMeasureForOnePeriod: simultaneityCount forInputCombination: startingSelection.
		simultaneityCount := inputSourceCategoryTwentyNine addInputSimultaneityMeasureForOnePeriod: simultaneityCount forInputCombination: startingSelection.
		simultaneityCount := inputSourceCategoryThirty addInputSimultaneityMeasureForOnePeriod: simultaneityCount forInputCombination: startingSelection.
		].	
	favouredInputs addLast: (OrderedCollection new).
	1 to: 25 do: [:j|
		remainingLargest := ((simultaneityCount largest) at: 2).
		(favouredInputs last) addLast: (startingSelection at: remainingLargest).
		simultaneityCount at: remainingLargest put: 0.
		].
	].  "END do: ii"

"The favoured inputs are recorded for later analysis if required"
FavouredInputs := (favouredInputs deepCopy).

"The brain instance for the run is recorded in global variable X so that it can be examined after run completion"
X := (Brain new) initialize:2.
X configureFirstArea: favouredInputs. 

"Each category instance is presented for 200 milliseconds. The black box thalamus puts a 40 Hz frequency modulation on the spikes so that they are much more likely to occur within a 5 millisecond segment of each 25 millisecond modulation interval. To save on computation time and to test working memory simultaneous handling of multiple objects, three different category instances are presented in each 200 millisecond period, in three different modulation phases" 	
1 to: 40 do:  [:presentationCycles|
	X presentTripleCategoryInstance: inputSourceCategoryOne withSecondCategory: inputSourceCategoryTwo withThirdCategory: inputSourceCategoryThree.	
	X presentTripleCategoryInstance: inputSourceCategoryFour withSecondCategory: inputSourceCategoryFive withThirdCategory: inputSourceCategorySix.	
	X presentTripleCategoryInstance: inputSourceCategorySeven withSecondCategory: inputSourceCategoryEight withThirdCategory: inputSourceCategoryNine.	
	X presentTripleCategoryInstance: inputSourceCategoryTen withSecondCategory: inputSourceCategoryEleven withThirdCategory: inputSourceCategoryTwelve.		
	X presentTripleCategoryInstance: inputSourceCategoryThirteen withSecondCategory: inputSourceCategoryFourteen withThirdCategory: inputSourceCategoryFifteen.		
	X presentTripleCategoryInstance: inputSourceCategorySixteen withSecondCategory: inputSourceCategorySeventeen withThirdCategory: inputSourceCategoryEighteen.
	X presentTripleCategoryInstance: inputSourceCategoryNineteen withSecondCategory: inputSourceCategoryTwenty withThirdCategory: inputSourceCategoryTwentyOne.	
	X presentTripleCategoryInstance: inputSourceCategoryTwentyTwo withSecondCategory: inputSourceCategoryTwentyThree withThirdCategory: inputSourceCategoryTwentyFour.	
	X presentTripleCategoryInstance: inputSourceCategoryTwentyFive withSecondCategory: inputSourceCategoryTwentySix withThirdCategory: inputSourceCategoryTwentySeven.	
	X presentTripleCategoryInstance: inputSourceCategoryTwentyEight withSecondCategory: inputSourceCategoryTwentyNine withThirdCategory: inputSourceCategoryThirty.	
	].


time addLast: (DateAndTime current ). 

 2022-07-29T11:41:34.978+01:00



------

addInputSimultaneityMeasureForOnePeriod: t1 forInputCombination: t2 
	| t3 t4 t5 t6 |
	t3 := 5.
	1
		to: 40
		do: [:t14 | 
			t4 := OrderedCollection new.
			1
				to: t2 size
				do: [:t7 | t4 addLast: 0].
			1
				to: 15
				do: [:t11 | 
					t5 := self getSpikesInNextTimeslot.
					1
						to: t2 size
						do: [:t9 | (t5
									at: (t2 at: t9))
									= 1
								ifTrue: [t4 at: t9 put: 1]]].
			t6 := t2 total.
			t6 > t3
				ifTrue: [1
						to: t2 size
						do: [:t12 | (t4 at: t12)
									= 1
								ifTrue: [t1 at: t12 put: (t1 at: t12)
											+ 1]]]].
	^ t1


getSpikesInNextTimeslot
	| t1 t2 |
	currentTimeslot := currentTimeslot + 1.
	currentPhase := phaseAtInitialTimeslot + (currentTimeslot - 1).
	currentPhase := currentPhase - (75 * (currentPhase // 75)).
	currentPhase = 0
		ifTrue: [currentPhase := 75].
	CurrentPhase := currentPhase.
	t1 := OrderedCollection new.
	1
		to: category size
		do: [:t3 | 
			t2 := (category at: t3)
						* (ModulationProbabilityFactor at: currentPhase).
			t2 > IntegerCollectionForInputStateGeneration atRandom
				ifTrue: [t1 addLast: 1]
				ifFalse: [t1 addLast: 0]].
	^ t1
------
configureFirstArea: t1 
	| t2 t3 t4 |
	1
		to: NumberOfColumns
		do: [:t10 | 
			(visualCortex at: 1) addColumn.
			1
				to: PyramidalsPerColumnLayerOne
				do: [:t5 | 
					(visualCortex at: 1) showColumns last addLayerOnePyramidal.
					(visualCortex at: 1) showColumns last showLayerOnePyramidalsActivity addLast: false].
			1
				to: PyramidalsPerColumnLayerTwo
				do: [:t6 | 
					(visualCortex at: 1) showColumns last addLayerTwoPyramidal.
					(visualCortex at: 1) showColumns last showLayerOnePyramidalsActivity addLast: false].
			1
				to: PyramidalsPerColumnLayerThree
				do: [:t7 | 
					(visualCortex at: 1) showColumns last addLayerThreePyramidal.
					(visualCortex at: 1) showColumns last showLayerOnePyramidalsActivity addLast: false].
			1
				to: NumberOfLayerOneInterneurons
				do: [:t8 | 
					(visualCortex at: 1) showColumns last addLayerOneInterneuronWithMultipleSources: NumberOfColumns withThreshold: LayerOneInterneuronThreshold.
					(visualCortex at: 1) showColumns last showLayerOneInterneuronActivity addLast: 0].
			1
				to: NumberOfLayerTwoInterneurons
				do: [:t9 | 
					(visualCortex at: 1) showColumns last addLayerTwoInterneuronWithMultipleSources: NumberOfColumns withThreshold: LayerTwoInterneuronThreshold.
					(visualCortex at: 1) showColumns last showLayerTwoInterneuronActivity addLast: 0]].
	1
		to: NumberOfColumns
		do: [:t35 | 
			t3 := OrderedCollection new.
			1
				to: InputSpaceSize
				do: [:t11 | t3 addLast: t11].
			1
				to: BiasOnFavouredInputs
				do: [:t14 | 1
						to: t1 size
						do: [:t12 | t3
								addLast: ((t1 at: t35)
										at: t12)]].
			1
				to: PyramidalsPerColumnLayerOne
				do: [:t18 | 
					t2 := ((visualCortex at: 1) showColumns at: t35) showLayerOnePyramidals at: t18.
					1
						to: NumberOfBranchesPerLayerOnePyramidal
						do: [:t16 | 
							t2 addDendriteBranch: DendriticBranchThresholdLayerOne.
							1
								to: NumberOfConditionDefiningInputsPerCorticalLayerOneBranch
								do: [:t15 | t2 showBasalDendrite showDistalBranches last addExcitatoryInput: t3 atRandom]].
					1
						to: NumberOfLayerOneInterneurons
						do: [:t17 | 
							t2 showBasalDendrite addNewProximalInput: t17.
							t2 showBasalDendrite addNewProximalInputWeight: LayerOneInterneuronOutputSynapticStrengths]].
			1
				to: PyramidalsPerColumnLayerTwo
				do: [:t22 | 
					t2 := ((visualCortex at: 1) showColumns at: t35) showLayerTwoPyramidals at: t22.
					1
						to: NumberOfBranchesPerLayerTwoPyramidal
						do: [:t20 | 
							t2 addDendriteBranch: DendriticBranchThresholdLayerTwo.
							1
								to: NumberOfConditionDefiningInputsPerCorticalLayerTwoBranch
								do: [:t19 | t2 showBasalDendrite showDistalBranches last addExcitatoryInput: PyramidalsPerColumnLayerOne atRandom]].
					1
						to: NumberOfLayerTwoInterneurons
						do: [:t21 | 
							t2 showBasalDendrite addNewProximalInput: t21.
							t2 showBasalDendrite addNewProximalInputWeight: LayerTwoInterneuronOutputSynapticStrengths]].
			1
				to: PyramidalsPerColumnLayerThree
				do: [:t26 | 
					t2 := ((visualCortex at: 1) showColumns at: t35) showLayerThreePyramidals at: t26.
					t2 showBasalDendrite changeThreshold: CorticalLayerThreeBasalDendriteThreshold.
					1
						to: NumberOfBranchesPerLayerThreePyramidal
						do: [:t25 | 
							t2 addDendriteBranch: DendriticBranchThresholdLayerThree.
							1
								to: NumberOfConditionDefiningInputsPerCorticalLayerThreeBranch
								do: [:t23 | t2 showBasalDendrite showDistalBranches last addExcitatoryInput: PyramidalsPerColumnLayerTwo atRandom withWeight: InitialLayerThreeSynapticWeight].
							1
								to: NumberOfConditionRecordingOutputsFromBlackBoxHippocampus
								do: [:t24 | t2 showBasalDendrite showDistalBranches last addConditionRecordingManagementInput: t24]]].
			1
				to: NumberOfLayerOneInterneurons
				do: [:t30 | 
					t4 := ((visualCortex at: 1) showColumns at: t35) showLayerOneInterneurons at: t30.
					1
						to: NumberOfColumns
						do: [:t29 | 
							t29 = t35
								ifFalse: [1
										to: NumberOfInputsToLayerOneInterneuronsFromEachOtherColumn
										do: [:t27 | 
											t4 addInput: PyramidalsPerColumnLayerOne atRandom fromSource: t29.
											t4 addInputWeight: LayerOneInterneuronInputSynapticStrengths fromSource: t29]].
							t29 = t35
								ifTrue: [1
										to: NumberOfInputsToLayerOneInterneuronsFromOwnColumn
										do: [:t28 | 
											t4 addInput: PyramidalsPerColumnLayerOne atRandom fromSource: t29.
											t4 addInputWeight: LayerOneInterneuronInputSynapticStrengths fromSource: t29]]]].
			1
				to: NumberOfLayerTwoInterneurons
				do: [:t34 | 
					t4 := ((visualCortex at: 1) showColumns at: t35) showLayerTwoInterneurons at: t34.
					1
						to: NumberOfColumns
						do: [:t33 | 
							t33 = t35
								ifFalse: [1
										to: NumberOfInputsToLayerTwoInterneuronsFromEachOtherColumn
										do: [:t31 | 
											t4 addInput: PyramidalsPerColumnLayerTwo atRandom fromSource: t33.
											t4 addInputWeight: LayerTwoInterneuronInputSynapticStrengths fromSource: t33]].
							t33 = t35
								ifTrue: [1
										to: NumberOfInputsToLayerTwoInterneuronsFromOwnColumn
										do: [:t32 | 

---------

presentTripleCategoryInstance: t1 withSecondCategory: t2 withThirdCategory: t3 
	| t4 t5 t6 t7 t8 t9 |
	1
		to: 600
		do: [:t13 | 
			t4 := t1 getSpikesInNextTimeslot: t2 withThirdCategory: t3.
			Y
				addLast: (X presentInputsInOneTimeslotToArea1WithBlackBoxHippocampus: t4).
			t7 := 0.
			1
				to: NumberOfColumns
				do: [:t10 | t7 := t7 + ((Y last at: t10)
									at: 3) total].
			t8 := 0.
			1
				to: NumberOfColumns
				do: [:t11 | t8 := t8 + ((Y last at: t11)
									at: 2) total].
			t9 := 0.
			1
				to: NumberOfColumns
				do: [:t12 | t9 := t9 + ((Y last at: t12)
									at: 1) total]].
	t5 := Y copyFrom: Y size - 599 to: Y size.
	t6 := OrderedCollection new.
	1
		to: 8
		do: [:t16 | 75 * (t16 - 1) + 1
				to: 75 * (t16 - 1) + 21
				do: [:t14 | t6
						addLast: (Y at: t14)]].
	PresentationResults
		addLast: (t6 totalAcrossTimeslots: 3).
	t6 := OrderedCollection new.
	1
		to: 8
		do: [:t19 | 75 * (t19 - 1) + 48
				to: 75 * (t19 - 1) + 71
				do: [:t17 | t6
						addLast: (Y at: t17)]].
	PresentationResults
		addLast: (t6 totalAcrossTimeslots: 3).
	t6 := OrderedCollection new.
	1
		to: 8
		do: [:t22 | 75 * (t22 - 1) + 27
				to: 75 * (t22 - 1) + 45
				do: [:t20 | t6
						addLast: (Y at: t20)]].
	PresentationResults
		addLast: (t6 totalAcrossTimeslots: 3).
	Y := OrderedCollection new.

getSpikesInNextTimeslot: t1 withThirdCategory: t2  [NOTE THE DIFFERENCE FROM THE EARLIER ONE]
	| t3 t4 t5 t6 t7 t8 |
	currentTimeslot := currentTimeslot + 1.
	currentPhase := phaseAtInitialTimeslot + (currentTimeslot - 1).
	currentPhase := currentPhase - (75 * (currentPhase // 75)).
	currentPhase = 0
		ifTrue: [currentPhase := 75].
	t5 := currentPhase + 25.
	t5 > 75
		ifTrue: [t5 := t5 - 75].
	t6 := t1 showCategory.
	t7 := t5 + 25.
	t7 > 75
		ifTrue: [t7 := t7 - 75].
	t8 := t2 showCategory.
	t3 := OrderedCollection new.
	1
		to: category size
		do: [:t9 | 
			t4 := (category at: t9)
						* (ModulationProbabilityFactor at: currentPhase) + ((t6 at: t9)
							* (ModulationProbabilityFactor at: t5)) + ((t8 at: t9)
							* (ModulationProbabilityFactor at: t7)).
			t4 > IntegerCollectionForInputStateGeneration atRandom
				ifTrue: [t3 addLast: 1]
				ifFalse: [t3 addLast: 0]].
	^ t3


presentInputsInOneTimeslotToArea1WithBlackBoxHippocampus: t1 
	| t2 t3 t4 t5 |
	t3 := (hippocampus at: 1) showCurrentHippocampalOutputs.
	t2 := (visualCortex at: 1)
				presentInputsInOneTimeslotToCorticalArea: t1
				withRecordingManagementInputs: t3.
	RecordingManagementInputsPerTimeslot addLast: t3 deepCopy.
	t5 := OrderedCollection new.
	1
		to: (visualCortex at: 1) showColumns size
		do: [:t6 | t5
				addLast: ((t2 at: t6)
						at: 2)].
	t4 := OrderedCollection new.
	1
		to: (visualCortex at: 1) showColumns size
		do: [:t8 | t4
				addLast: ((t2 at: t8)
						at: 3)].
	(hippocampus at: 1)
		updateHippocampalRecordsForMultipleModulationCycles: t4
		withInternalActivity: t5.
	^ t2

presentInputsInOneTimeslotToCorticalArea: t1 withRecordingManagementInputs: t2 
	| t3 t4 |
	currentOutputs := OrderedCollection new.
	1
		to: columns size
		do: [:t5 | currentOutputs
				addLast: ((columns at: t5)
						presentInputsToColumn: t1
						withRecordingManagementInputs: (t2 at: t5))].
	t3 := OrderedCollection new.
	1
		to: columns size
		do: [:t7 | t3
				addLast: ((currentOutputs at: t7)
						at: 1)].
	1
		to: columns size
		do: [:t9 | (columns at: t9)
				updateLayerOneInterneuronActivity: t3].
	t4 := OrderedCollection new.
	1
		to: columns size
		do: [:t11 | t4
				addLast: ((currentOutputs at: t11)
						at: 2)].
	1
		to: columns size
		do: [:t13 | (columns at: t13)
				updateLayerTwoInterneuronActivity: t4].
	^ currentOutputs


presentInputsToColumn: t1 withRecordingManagementInputs: t2 
	| t3 t4 t5 t6 |
	t3 := OrderedCollection new.
	t4 := OrderedCollection new.
	t5 := OrderedCollection new.
	1
		to: layerOnePyramidals size
		do: [:t7 | t3
				addLast: ((layerOnePyramidals at: t7)
						presentExcitatoryInputsToPyramidalNeuron: t1
						withInterneuronActivity: layerOneInterneuronActivity deepCopy)].
	1
		to: layerTwoPyramidals size
		do: [:t9 | t4
				addLast: ((layerTwoPyramidals at: t9)
						presentExcitatoryInputsToPyramidalNeuron: t3
						withInterneuronActivity: layerTwoInterneuronActivity deepCopy)].
	1
		to: layerThreePyramidals size
		do: [:t11 | t5
				addLast: ((layerThreePyramidals at: t11)
						presentExcitatoryInputsToPyramidalNeuron: t4
						withRecordingManagementInputs: t2)].
	layerOnePyramidalsActivity := t3.
	layerTwoPyramidalsActivity := t4.
	layerThreePyramidalsActivity := t5.
	t6 := OrderedCollection new.
	t6 addLast: layerOnePyramidalsActivity.
	t6 addLast: layerTwoPyramidalsActivity.
	t6 addLast: layerThreePyramidalsActivity.
	^ t6

presentExcitatoryInputsToPyramidalNeuron: t1 withInterneuronActivity: t2 
	timeSincePreviousFiring := timeSincePreviousFiring + 1.
	firingStatus := basalDendrite presentExcitatoryInputs: t1 withModulatoryInputs: t2.
	firingStatus = true
		ifTrue: [timeSincePreviousFiring := 0].
	firingStatus = true
		ifTrue: [1
				to: basalDendrite showDistalBranches size
				do: [:t3 | (basalDendrite showDistalBranches at: t3) adjustWeightsOfRecentlyActiveInputs]].
	firingStatus = true
		ifTrue: [synapticWeightReductionTendency := BDNFincrementPerFiring + synapticWeightReductionTendency].
	synapticWeightReductionTendency > BDNFconcentrationThresholdForReductionInSynapticWeights
		ifTrue: [self reduceSynapticWeights: FrequentFiringReductionInSynapticWeightsProportion.
			synapticWeightReductionTendency := synapticWeightReductionTendency - BDNFdecrementFollowingWeightReduction].
	synapticWeightReductionTendency := synapticWeightReductionTendency * BDNFconcentrationReductionPerTimeslot.
	firingStatus = true
		ifTrue: [^ 1].
	firingStatus = true
		ifFalse: [^ 0]



basalDendrite: presentExcitatoryInputs: t1 withModulatoryInputs: t2 
	| t3 t4 t5 t6 |
	potentialRecord addLast: 0.
	potentialRecord removeFirst.
	1
		to: distalBranches size
		do: [:t9 | ((distalBranches at: t9)
					presentSingleSourceExcitatoryInputsToBranch: t1)
				ifTrue: [1
						to: potentialRecord size
						do: [:t7 | potentialRecord at: t7 put: (potentialRecord at: t7)
									+ (InjectedPotentialDecayCurve at: t7)]]].
	1
		to: proximalInputs size
		do: [:t13 | (t2
					at: (proximalInputs at: t13))
					= 1
				ifTrue: [1
						to: potentialRecord size
						do: [:t11 | potentialRecord at: t11 put: (potentialRecord at: t11)
									+ ((proximalInputWeights at: t13)
											* (InjectedPotentialDecayCurve at: t11))]]].
	t3 := potentialRecord at: 1.
	t4 := 1000 * (t3 - threshold / threshold).
	t4 < 0
		ifTrue: [t4 := 0].
	t4 > 100
		ifTrue: [t4 := 100].
	firingStatus := false.
	t4 > IntegerCollection atRandom
		ifTrue: [firingStatus := true].
	firingStatus = true
		ifTrue: [1
				to: potentialRecord size
				do: [:t15 | potentialRecord at: t15 put: 0]].
	t5 := OrderedCollection new.
	1
		to: distalBranches size
		do: [:t17 | (distalBranches at: t17) showExcitatoryInputs size < 3
				ifTrue: [t5 addLast: t17 deepCopy]].
	1
		to: t5 size
		do: [:t19 | 
			t6 := t5 largest.
			distalBranches
				removeAt: (t6 at: 1).
			t5
				at: (t6 at: 2)

presentSingleSourceExcitatoryInputsToBranch: t1 
	| t2 t3 |
	potentialRecord removeFirst.
	potentialRecord addLast: 0.
	timeSinceLastActivityOfBranch := timeSinceLastActivityOfBranch + 1.
	1
		to: recentWeightChangeHistory size
		do: [:t6 | 1
				to: ((recentWeightChangeHistory at: t6)
						at: 1) size
				do: [:t4 | ((recentWeightChangeHistory at: t6)
						at: 1)
						at: t4
						put: (((recentWeightChangeHistory at: t6)
								at: 1)
								at: t4)
								+ 1]].
	1
		to: recentWeightChangeHistory size
		do: [:t8 | ((recentWeightChangeHistory at: t8)
					at: 1) size > 0
				ifTrue: [((recentWeightChangeHistory at: t8)
							at: 1) first > 600
						ifTrue: [excitatoryInputWeights at: t8 put: (excitatoryInputWeights at: t8)
									/ ((recentWeightChangeHistory at: t8)
											at: 2) first.
							((recentWeightChangeHistory at: t8)
								at: 1) removeFirst.
							((recentWeightChangeHistory at: t8)
								at: 2) removeFirst]]].
	1
		to: recentWeightChangeHistory size
		do: [:t10 | ((recentWeightChangeHistory at: t10)
					at: 1) size >= BranchContributionsWithin200msecForPermanentWeightChange
				ifTrue: [(recentWeightChangeHistory at: t10)
						at: 1
						put: OrderedCollection new.
					(recentWeightChangeHistory at: t10)
						at: 2
						put: OrderedCollection new]].
	1
		to: recentActivityOfExcitatoryInputs size
		do: [:t12 | recentActivityOfExcitatoryInputs at: t12 put: 1
					+ (recentActivityOfExcitatoryInputs at: t12)].
	1
		to: excitatoryInputs size
		do: [:t16 | (t1
					at: (excitatoryInputs at: t16))
					= 1
				ifTrue: [recentActivityOfExcitatoryInputs at: t16 put: 0.
					1
						to: potentialRecord size
						do: [:t14 | potentialRecord at: t14 put: (potentialRecord at: t14)
									+ ((excitatoryInputWeights at: t16)
											* (InjectedPotentialDecayCurve at: t14))]]].
	t2 := potentialRecord at: 1.
	t3 := 1000 * (t2 - threshold / threshold).
	t3 < 0
		ifTrue: [t3 := 0].
	t3 > 100
		ifTrue: [t3 := 100].
	firingStatus := false.
	t3 > IntegerCollection atRandom
		ifTrue: [firingStatus := true].
	firingStatus = true
		ifTrue: [1
				to: potentialRecord size
				do: [:t18 | potentialRecord at: t18 put: 0].
			timeSinceLastActivityOfBranch := 0.

presentExcitatoryInputsToPyramidalNeuron: t1 withRecordingManagementInputs: t2 
	timeSincePreviousFiring := timeSincePreviousFiring + 1.
	firingStatus := basalDendrite presentExcitatoryInputs: t1 withRecordingManagementInputs: t2.
	firingStatus = true
		ifTrue: [timeSincePreviousFiring := 0].
	firingStatus = true
		ifTrue: [1
				to: basalDendrite showDistalBranches size
				do: [:t3 | (basalDendrite showDistalBranches at: t3) adjustWeightsOfRecentlyActiveInputs]].
	firingStatus = true
		ifTrue: [^ 1].
	firingStatus = true
		ifFalse: [^ 0]

basalDendrite: presentExcitatoryInputs: t1 withRecordingManagementInputs: t2 
	| t3 t4 t5 t6 |
	potentialRecord addLast: 0.
	potentialRecord removeFirst.
	1
		to: distalBranches size
		do: [:t9 | ((distalBranches at: t9)
					presentExcitatoryInputsToBranch: t1
					withRecordingManagementInputs: t2)
				ifTrue: [1
						to: potentialRecord size
						do: [:t7 | potentialRecord at: t7 put: (potentialRecord at: t7)
									+ (InjectedPotentialDecayCurve at: t7)]]].
	t3 := potentialRecord at: 1.
	t4 := 1000 * (t3 - threshold / threshold).
	t4 < 0
		ifTrue: [t4 := 0].
	t4 > 100
		ifTrue: [t4 := 100].
	firingStatus := false.
	t4 > IntegerCollection atRandom
		ifTrue: [firingStatus := true].
	firingStatus = true
		ifTrue: [1
				to: potentialRecord size
				do: [:t11 | potentialRecord at: t11 put: 0]].
	t5 := OrderedCollection new.
	1
		to: distalBranches size
		do: [:t13 | (distalBranches at: t13) showExcitatoryInputs size < 3
				ifTrue: [t5 addLast: t13 deepCopy]].
	1
		to: t5 size
		do: [:t15 | 
			t6 := t5 largest.
			distalBranches
				removeAt: (t6 at: 1).
			t5
				at: (t6 at: 2)


presentExcitatoryInputsToBranch: t1 withRecordingManagementInputs: t2 
	(t1 at: 1) isCollection
		ifTrue: [firingStatus := self presentMultipleSourceExcitatoryInputsToBranch: t1 withRecordingManagementInputs: t2].
	(t1 at: 1) isCollection
		ifFalse: [firingStatus := self presentSingleSourceExcitatoryInputsToBranch: t1 withRecordingManagementInputs: t2].
	^ firingStatus

presentMultipleSourceExcitatoryInputsToBranch: t1 withRecordingManagementInputs: t2 
	| t3 t4 |
	potentialRecord removeFirst.
	potentialRecord addLast: 0.
	timeSinceLastActivityOfBranch := timeSinceLastActivityOfBranch + 1.
	1
		to: recentWeightChangeHistory size
		do: [:t9 | 1
				to: (recentWeightChangeHistory at: t9) size
				do: [:t7 | 1
						to: (((recentWeightChangeHistory at: t9)
								at: t7)
								at: 1) size
						do: [:t5 | (((recentWeightChangeHistory at: t9)
								at: t7)
								at: 1)
								at: t5
								put: ((((recentWeightChangeHistory at: t9)
										at: t7)
										at: 1)
										at: t5)
										+ 1]]].
	1
		to: recentWeightChangeHistory size
		do: [:t13 | 1
				to: (recentWeightChangeHistory at: t13) size
				do: [:t11 | (((recentWeightChangeHistory at: t13)
							at: t11)
							at: 1) size > 0
						ifTrue: [(((recentWeightChangeHistory at: t13)
									at: t11)
									at: 1) first > 600
								ifTrue: [(excitatoryInputWeights at: t13)
										at: t11
										put: ((excitatoryInputWeights at: t13)
												at: t11)
												/ (((recentWeightChangeHistory at: t13)
														at: t11)
														at: 2) first.
									(((recentWeightChangeHistory at: t13)
										at: t11)
										at: 1) removeFirst.
									(((recentWeightChangeHistory at: t13)
										at: t11)
										at: 2) removeFirst]]]].
	1
		to: recentWeightChangeHistory size
		do: [:t17 | 1
				to: (recentWeightChangeHistory at: t17) size
				do: [:t15 | (((recentWeightChangeHistory at: t17)
							at: t15)
							at: 1) size >= 5
						ifTrue: [((recentWeightChangeHistory at: t17)
								at: t15)
								at: 1
								put: OrderedCollection new.
							((recentWeightChangeHistory at: t17)
								at: t15)
								at: 2
								put: OrderedCollection new]]].
	1
		to: recentActivityOfExcitatoryInputs size
		do: [:t21 | 1
				to: (recentActivityOfExcitatoryInputs at: t21) size
				do: [:t19 | (recentActivityOfExcitatoryInputs at: t21)
						at: t19
						put: 1
								+ ((recentActivityOfExcitatoryInputs at: t21)
										at: t19)]].
	1
		to: excitatoryInputs size
		do: [:t27 | 1
				to: (excitatoryInputs at: t27) size
				do: [:t25 | ((t1 at: t27)
							at: ((excitatoryInputs at: t27)
									at: t25))
							= 1
						ifTrue: [(recentActivityOfExcitatoryInputs at: t27)
								at: t25
								put: 0.
							1
								to: potentialRecord size
								do: [:t23 | potentialRecord at: t23 put: (potentialRecord at: t23)
											+ (((excitatoryInputWeights at: t27)
													at: t25)
													* (InjectedPotentialDecayCurve at: t23))]]]].
	1
		to: conditionRecordingManagementInputs size
		do: [:t31 | (t2
					at: (conditionRecordingManagementInputs at: t31))
					= 1
				ifTrue: [1
						to: potentialRecord size
						do: [:t29 | potentialRecord at: t29 put: (potentialRecord at: t29)
									+ ((conditionRecordingManagementInputWeights at: t31)
											* (InjectedPotentialDecayCurve at: t29))]]].
	t3 := potentialRecord at: 1.
	t4 := 1000 * (t3 - threshold / threshold).
	t4 < 0
		ifTrue: [t4 := 0].
	t4 > 100
		ifTrue: [t4 := 100].
	firingStatus := false.
	t4 > IntegerCollection atRandom
		ifTrue: [firingStatus := true].
	firingStatus = true
		ifTrue: [1
				to: potentialRecord size
				do: [:t33 | potentialRecord at: t33 put: 0].
			timeSinceLastActivityOfBranch := 0.

presentSingleSourceExcitatoryInputsToBranch: t1 withRecordingManagementInputs: t2 
	| t3 t4 |
	potentialRecord removeFirst.
	potentialRecord addLast: 0.
	timeSinceLastActivityOfBranch := timeSinceLastActivityOfBranch + 1.
	1
		to: recentWeightChangeHistory size
		do: [:t7 | 1
				to: ((recentWeightChangeHistory at: t7)
						at: 1) size
				do: [:t5 | ((recentWeightChangeHistory at: t7)
						at: 1)
						at: t5
						put: (((recentWeightChangeHistory at: t7)
								at: 1)
								at: t5)
								+ 1]].
	1
		to: recentWeightChangeHistory size
		do: [:t9 | ((recentWeightChangeHistory at: t9)
					at: 1) size > 0
				ifTrue: [((recentWeightChangeHistory at: t9)
							at: 1) first > 600
						ifTrue: [excitatoryInputWeights at: t9 put: (excitatoryInputWeights at: t9)
									/ ((recentWeightChangeHistory at: t9)
											at: 2) first.
							((recentWeightChangeHistory at: t9)
								at: 1) removeFirst.
							((recentWeightChangeHistory at: t9)
								at: 2) removeFirst]]].
	1
		to: recentWeightChangeHistory size
		do: [:t11 | ((recentWeightChangeHistory at: t11)
					at: 1) size >= BranchContributionsWithin200msecForPermanentWeightChange
				ifTrue: [(recentWeightChangeHistory at: t11)
						at: 1
						put: OrderedCollection new.
					(recentWeightChangeHistory at: t11)
						at: 2
						put: OrderedCollection new]].
	1
		to: recentActivityOfExcitatoryInputs size
		do: [:t13 | recentActivityOfExcitatoryInputs at: t13 put: 1
					+ (recentActivityOfExcitatoryInputs at: t13)].
	1
		to: excitatoryInputs size
		do: [:t17 | (t1
					at: (excitatoryInputs at: t17))
					= 1
				ifTrue: [recentActivityOfExcitatoryInputs at: t17 put: 0.
					1
						to: potentialRecord size
						do: [:t15 | potentialRecord at: t15 put: (potentialRecord at: t15)
									+ ((excitatoryInputWeights at: t17)
											* (InjectedPotentialDecayCurve at: t15))]]].
	1
		to: conditionRecordingManagementInputs size
		do: [:t21 | t2 = 1
				ifTrue: [1
						to: potentialRecord size
						do: [:t19 | potentialRecord at: t19 put: (potentialRecord at: t19)
									+ ((conditionRecordingManagementInputWeights at: t21)
											* (InjectedPotentialDecayCurve at: t19))]]].
	t3 := potentialRecord at: 1.
	t4 := 1000 * (t3 - threshold / threshold).
	t4 < 0
		ifTrue: [t4 := 0].
	t4 > 100
		ifTrue: [t4 := 100].
	firingStatus := false.
	t4 > IntegerCollection atRandom
		ifTrue: [firingStatus := true].
	firingStatus = true
		ifTrue: [1
				to: potentialRecord size
				do: [:t23 | potentialRecord at: t23 put: 0].
			timeSinceLastActivityOfBranch := 0.

updateLayerOneInterneuronActivity: t1 
	1
		to: layerOneInterneurons size
		do: [:t2 | layerOneInterneuronActivity
				at: t2
				put: ((layerOneInterneurons at: t2)
						presentInputsFromMultipleSources: t1)]


updateHippocampalRecordsForMultipleModulationCycles: t1 withInternalActivity: t2 
	| t3 t4 t5 t6 t7 t8 |
	inputsFromLayerThree addLast: t1 deepCopy.
	inputsFromLayerTwo addLast: t2 deepCopy.
	outputsToLayerThree size = 0
		ifTrue: [t3 := self determineColumnActivityOver75timeslotsForEachModulation.
			t4 := OrderedCollection new.
			1
				to: 3
				do: [:t10 | 
					t7 := t3 at: t10.
					t6 := 0.
					1
						to: NumberOfColumns
						do: [:t9 | (t7 at: t9)
									> 1
								ifTrue: [t6 := t6 + 1]].
					t4 addLast: t6].
			t5 := self determineIntermediateLayerColumnActivityOver75timeslotsForEachModulation.
			t5 eliminateColumnsWithStrongLayerThreeActivity: t3.
			t8 := OrderedCollection new.
			1
				to: 3
				do: [:t11 | 
					t8 addLast: OrderedCollection new.
					((t5 at: t11) largest at: 1)
							= 0
						ifFalse: [(t4 at: t11)
									= 2
								ifTrue: [((t5 at: t11) largest at: 1)
											> 0
										ifTrue: [t8 last
												addLast: ((t5 at: t11) largest at: 2)]].
							(t4 at: t11)
									= 1
								ifTrue: [((t5 at: t11) largest at: 1)
											> 0
										ifTrue: [t8 last
												addLast: ((t5 at: t11) largest at: 2).
											(t5 at: t11)
												at: (t8 last at: 1)
												put: 0].
									((t5 at: t11) largest at: 1)
											> 0
										ifTrue: [(t8 at: t11)
												addLast: ((t5 at: t11) largest at: 2)]].
							(t4 at: t11)
									= 0
								ifTrue: [((t5 at: t11) largest at: 1)
											> 0
										ifTrue: [t8 last
												addLast: ((t5 at: t11) largest at: 2).
											(t5 at: t11)
												at: (t8 last at: 1)
												put: 0].
									((t5 at: t11) largest at: 1)
											> 0
										ifTrue: [(t8 at: t11)
												addLast: ((t5 at: t11) largest at: 2).
											(t5 at: t11)
												at: (t8 last at: 2)
												put: 0].
									((t5 at: t11) largest at: 1)
											> 0
										ifTrue: [t8 last
												addLast: ((t5 at: t11) largest at: 2)]]]].
			self constructMultiplexedOutputsForNext25milliseconds: t8.
			inputsFromLayerThree := OrderedCollection new.
			inputsFromLayerTwo := OrderedCollection new]

determineColumnActivityOver75timeslotsForEachModulation
	| t1 |
	t1 := OrderedCollection new.
	1
		to: 3
		do: [:t3 | 
			t1 addLast: OrderedCollection new.
			1
				to: NumberOfColumns
				do: [:t2 | t1 last addLast: 0]].
	4
		to: 13
		do: [:t5 | 1
				to: NumberOfColumns
				do: [:t4 | (t1 at: 1)
						at: t4
						put: ((t1 at: 1)
								at: t4)
								+ ((inputsFromLayerThree at: t5)
										at: t4) total]].
	29
		to: 38
		do: [:t7 | 1
				to: NumberOfColumns
				do: [:t6 | (t1 at: 2)
						at: t6
						put: ((t1 at: 2)
								at: t6)
								+ ((inputsFromLayerThree at: t7)
										at: t6) total]].
	54
		to: 63
		do: [:t9 | 1
				to: NumberOfColumns
				do: [:t8 | (t1 at: 3)
						at: t8
						put: ((t1 at: 3)
								at: t8)
								+ ((inputsFromLayerThree at: t9)
										at: t8) total]].
	^ t1

determineIntermediateLayerColumnActivityOver75timeslotsForEachModulation
	| t1 |
	t1 := OrderedCollection new.
	1
		to: 3
		do: [:t3 | 
			t1 addLast: OrderedCollection new.
			1
				to: NumberOfColumns
				do: [:t2 | t1 last addLast: 0]].
	1
		to: 10
		do: [:t5 | 1
				to: NumberOfColumns
				do: [:t4 | (t1 at: 1)
						at: t4
						put: ((t1 at: 1)
								at: t4)
								+ ((inputsFromLayerTwo at: t5)
										at: t4) total]].
	26
		to: 35
		do: [:t7 | 1
				to: NumberOfColumns
				do: [:t6 | (t1 at: 2)
						at: t6
						put: ((t1 at: 2)
								at: t6)
								+ ((inputsFromLayerTwo at: t7)
										at: t6) total]].
	51
		to: 60
		do: [:t9 | 1
				to: NumberOfColumns
				do: [:t8 | (t1 at: 3)
						at: t8
						put: ((t1 at: 3)
								at: t8)
								+ ((inputsFromLayerTwo at: t9)
										at: t8) total]].
	^ t1



eliminateColumnsWithStrongLayerThreeActivity: t1 
	1
		to: 3
		do: [:t3 | 1
				to: NumberOfColumns
				do: [:t2 | ((t1 at: t3)
							at: t2)
							> 1
						ifTrue: [(self at: t3)
								at: t2
								put: 0]]]




constructMultiplexedOutputsForNext25milliseconds: t1 
	outputsToLayerThree := OrderedCollection new.
	1
		to: 75
		do: [:t3 | 
			outputsToLayerThree addLast: OrderedCollection new.
			1
				to: NumberOfColumns
				do: [:t2 | outputsToLayerThree last addLast: 0]].
	1
		to: (t1 at: 1) size
		do: [:t5 | 1
				to: 10
				do: [:t4 | (outputsToLayerThree at: t4)
						at: ((t1 at: 1)
								at: t5)
						put: 1]].
	1
		to: (t1 at: 2) size
		do: [:t8 | 26
				to: 35
				do: [:t7 | (outputsToLayerThree at: t7)
						at: ((t1 at: 2)
								at: t8)
						put: 1]].
	1
		to: (t1 at: 3) size
		do: [:t11 | 51
				to: 60
				do: [:t10 | (outputsToLayerThree at: t10)
						at: ((t1 at: 3)
								at: t11)
						put: 1]].
	1
		to: 3
		do: [:t13 | strongActivityCount at: t13 put: (strongActivityCount at: t13)
					+ (t1 at: t13) size]


totalAcrossTimeslots: t1 
	| t2 |
	t2 := OrderedCollection new.
	1
		to: (self at: 1) size
		do: [:t3 | t2 addLast: 0].
	1
		to: self size
		do: [:t7 | 1
				to: (self at: 1) size
				do: [:t5 | t2 at: t5 put: (t2 at: t5)
							+ (((self at: t7)
									at: t5)
									at: t1) total]].
	^ t2


"CategoryIdentifications"
 
	| categoryIdentifications categoryWeights currentOutputs currentSecondCategoryIdentification |

numberOfCategories := 30.	
resultsToBeProcessed := PresentationResults.
	
presentationStartPoint := 901.
presentationStopPoint := 1200.
	
categoryIdentifications := OrderedCollection new.
1 to: 3 do: [:j| categoryIdentifications addLast: (OrderedCollection new).].

presentationStartPoint to: presentationStopPoint do: [:instance|
	categoryWeights := OrderedCollection new.
	currentOutputs := (resultsToBeProcessed at: instance).
	1 to: numberOfCategories do: [:category|
		currentCategoryWeight := 0.
		1 to: NumberOfColumns do: [:column|
			currentCategoryWeight := currentCategoryWeight + ((currentOutputs at: column) * ((ColumnWeightsInFavourOfCategories at: category) at: column)).
			].  "end do: [:column|"
		categoryWeights addLast: currentCategoryWeight.
		]. "end do: [:category|"
		
		
	currentCategoryIdentification := categoryWeights largest.	
	(categoryIdentifications at: 1) addLast: (currentCategoryIdentification at: 2).
	categoryWeights at: (currentCategoryIdentification at: 2)
	                            put: (1 negated).
	currentSecondCategoryIdentification := categoryWeights largest.
	(categoryIdentifications at: 2) addLast: (currentSecondCategoryIdentification at: 2).
	categoryWeights at: (currentSecondCategoryIdentification at: 2)
	                            put: (1 negated).
	currentThirdCategoryIdentification := categoryWeights largest.	
	(categoryIdentifications at: 3) addLast: (currentThirdCategoryIdentification at: 2).

		
	].  "end do: [:instance|"
	
^CategoryIdentifications := categoryIdentifications
 

"CalculationOfColumnWeightsInFavourOfThirtyCategories

This method uses the total number of spikes produced by layer three cortical neurons in each column in each category instance presentation. These spike counts are recorded in PresentationResults.

The global variable ColumnWeightsInFavourOfCategories is a 'black box' basal ganglia. It is implemented as an OrderedCollection of OrderedCollections, one for each category. Each of the OrderedCollections models the cortical weights of each column into the basal ganglia neuron corresponding with the behaviour of identifying one category.

Hence in response to a presentation, the total weights in favour of each category are determined by finding the total across all columns of (number of spikes from the column * weight of category for that column). The category with the largest weight is then selected.

In this method, using the cortical outputs of the presentations from startPoint to stopPoint, the weights in favour of each category are defined. 

It is assumed that the brain is provided with information indicating the correct category during these presentations. The effect is that FIRST, the most strongly recommended category using previous weights is determined. SECOND the weights of active columns in favour of the correct category are increased. THIRD, if the initial identification was incorrect, the weights of active columns in favour of that incorrect category are reduced." 

   | resultsToBeProcessed startPoint stopPoint numberOfCategories numberOfPresentations target currentIdentity currentPresentation currentCategoryWeightInCurrentPresentation weightsOfCategoriesInCurrentPresentation referenceWeightsOfCurrentCategory  selectedCategory | 

startPoint := 601.
stopPoint := 900.

resultsToBeProcessed := PresentationResults copyFrom: startPoint to: stopPoint.
numberOfPresentations := 1 + stopPoint - startPoint. 

numberOfCategories := 30.

weightReductionFactor := WeightReductionFactor.

"The following code sets up the structure of column weights in favour of categories, setting all weights initially to zero"
ColumnWeightsInFavourOfCategories := OrderedCollection new.
1 to: numberOfCategories do: [:col1|
	ColumnWeightsInFavourOfCategories addLast: OrderedCollection new.
	1 to: NumberOfColumns do: [:j| (ColumnWeightsInFavourOfCategories last) addLast: 0].
	].   "END do col1"


"The following code sets up information about which category is presented in each presentation"
target := OrderedCollection new.
1 to: (numberOfPresentations/numberOfCategories) do: [:cat1|
	1 to: numberOfCategories do: [:k| target addLast: k].
	].


"The following do loop goes through each of the presentations. FIRST it determines which category is most strongly recommended using previously defined weights. SECOND it adds the number of spikes generated by each column to the defined weight of that column in favour of the correct category. THIRD, if the category it picked first was incorrect, the recommendation weights in favour of the incorrect category of all the columns that produced spikes are reduced by a factor of weightReductionFactor"
1 to: numberOfPresentations do: [:presentation|
	
"FIRST:  In the following code, for each presentation, the weights in favour of each category are calculated using the current ColumnWeightsInFavourOfCategories." 	
	currentIdentity := target at: presentation.
	currentPresentation := resultsToBeProcessed at: presentation.
	weightsOfCategoriesInCurrentPresentation := OrderedCollection new.
	1 to: numberOfCategories do: [:cat2|
		referenceWeightsOfCurrentCategory := (ColumnWeightsInFavourOfCategories at: cat2).	
		currentCategoryWeightInCurrentPresentation := 0.
		1 to: (currentPresentation size) do: [:col2|
			currentCategoryWeightInCurrentPresentation := currentCategoryWeightInCurrentPresentation + ((currentPresentation at: col2)*(referenceWeightsOfCurrentCategory at: col2)).
		].   "END do col2"
		weightsOfCategoriesInCurrentPresentation addLast: (currentCategoryWeightInCurrentPresentation).
	].   "END do cat2"
	
"In the following code, for each presentation, the category with the largest current recommendation weight is determined"				
selectedCategory := (weightsOfCategoriesInCurrentPresentation largest) at: 2.  "(largest at: 2) returns the index of largest"

"SECOND:  In the following code, for each presentation, the number of spikes generated by a column is added to the recorded weight of that column in favour of the correct category" 
	1 to: NumberOfColumns do: [:col4|
		(ColumnWeightsInFavourOfCategories at: currentIdentity)
			at: col4
			put: ((((ColumnWeightsInFavourOfCategories at: currentIdentity) at: col4)) + (currentPresentation at: col4)).
	].   "END do col4"
		
	
		
"THIRD:  if the original selection was incorrect,  decrease the weights in favour of the incorrectly selected category of any active columns"		
	(selectedCategory = currentIdentity) ifFalse: [
		1 to: NumberOfColumns do: [:col5|
			((currentPresentation at: col5) > 0) ifTrue: [
				(ColumnWeightsInFavourOfCategories at: selectedCategory)
					at: col5
					put: (((ColumnWeightsInFavourOfCategories at: selectedCategory) at: col5)/weightReductionFactor).	
			].   "END ((currentPresentation at: col5) > 0) ifTrue"				
		].   "END NumberOfColumns do"		
	].   "END (selectedCategory = currentIdentity) ifFalse"


].   "END do presentation"

^ColumnWeightsInFavourOfCategories